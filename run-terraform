#!/bin/bash

set -o pipefail

# -- User variables -----------------------------------------------------------

supported_terraform_commands=(apply destroy plan refresh state)

# -- Internal variables -------------------------------------------------------

working_dir=$(pwd)

bold='\033[1m'
reset='\033[0m'
blue='\033[1;34m'
red='\033[0;31m'
yellow='\033[1;33m'

info_level_weight=40
warn_level_weight=30
error_level_weight=20
debug_level_weight=10

terraform_version=$(terraform --version | head -n 1 | cut -d ' ' -f2)

# -- Signal Handlers ----------------------------------------------------------

for signal in SIGHUP SIGINT SIGTERM; do
    trap "printf \"\n${red}Error:${reset} Received interrupt signal ${signal}, exiting..\n\" >&2 && exit 1" ${signal}
done

error_trap_handler () {
    local exit_code=$1
    local line_no=$2
    printf "${red}Error:${reset} Caught unhandled error from command on line ${line_no}; command exited with exit code ${exit_code}\n" >&2
    exit ${exit_code}
}

enable_error_trap () {
    trap 'exit_code=${?}; line_no=${LINENO}; error_trap_handler ${exit_code} ${line_no}' ERR
}

# Ensure ERR trap is inherited by functions; else disable_error_trap won't work;
# Important note: with -E (errtrace) set the ERR trap will be inherited by functions,
# command substitutions, and commands executed in a sub-shell environment; for
# this reason ensure that disable_error_trap and enable_error_trap are used
# accordingly where this behaviour is NOT desired, for example to avoid SIGPIPE
# signals from command substitution pipelines; be particularly mindful of this
# with shorthand syntax [[ .. ]] && command -- this will trap with the condition
# return code unless written out fully, using the 'if' keyword,  or alternatively
# if wrapped within disable_error_trap and enable_error_trap calls
set -E

disable_error_trap () {
    trap '' ERR
}

# Enable ERR trap by default; disable where exit codes are inspected manually by
# using disable_error_trap and enable_error_trap where suitable
enable_error_trap

# -- Logging ------------------------------------------------------------------

initialise_logging () {
  # Read valid log level from environment or fallback to default level
  log_weight_name=$(echo "${LOGLEVEL:-INFO}_level_weight" | tr '[:upper:]' '[:lower:]')

  # Expand log level weight via indirection
  log_weight=${!log_weight_name}

  # Ensure log level was expanded to a valid weight or exit with error
  if [[ -z ${log_weight} ]]; then
      printf "${red}Error:${reset} Invalid log level '${LOGLEVEL}' set in environment, exiting..\n" >&2
      exit 1
  fi
}

log () {
  local verbosity=$1
  local colour=$2
  local title=$3
  local message=$4

  if [[ ${verbosity} -eq ${error_level_weight} ]]; then
      printf "${colour}${title}: ${message}${reset}\n" >&2
  elif [[ ${verbosity} -ge ${log_weight} ]]; then
      printf "${colour}${title}: ${message}${reset}\n" >&1
  fi
}

info () {
    log ${info_level_weight} ${blue} "Info" "$1"
}

warn () {
    log ${warn_level_weight} ${yellow} "Warning" "$1"
}

error () {
    log ${error_level_weight} ${red} "Error" "$1"
}

debug () {
    log ${debug_level_weight} ${yellow} "Debug" "$1"
}

# -- General ------------------------------------------------------------------

pushd () {
    debug "Changing to directory ${1}"
    disable_error_trap
    command pushd "${1}" > /dev/null
    exit_on_failure "${?}" "Unable to change to directory: ${bold}${1}${reset}"
    enable_error_trap
}

popd () {
    debug "Exiting directory $(pwd)"
    disable_error_trap
    command popd > /dev/null
    local exit_code="${?}"
    local directory_stack=( $(dirs) )
    exit_on_failure "${exit_code}" "Unable to change to new top directory of stack: ${bold}${directory_stack[0]}${reset}"
    enable_error_trap
}

contains_element () {
    local desired="${1}"
    local array=("${@:2}")

    debug "Checking for element '${desired}' in array of elements [${array[*]}]"

    for element in "${array[@]}"; do
        if [[ "${element}" == "${desired}" ]]; then
            debug "Match found for element '${desired}'"
            return 0
        fi
    done

    debug "No match found for element '${desired}'"
    return 1
}

export_terraform_env_var () {
    local key="${1}"
    local value="${2}"
    local export_key="TF_VAR_${key}"

    debug "Exporting environment variable: ${bold}${export_key}${normal}"
    export ${export_key}="${value}"
}

banner () {
    eval $(echo printf -- '"${1}%.0s"' {1..80})
    printf '\n'
}

exit_on_failure () {
    local exit_status=${1}
    local error_message=${2}

    if [[ ${exit_status} -ne 0 ]]; then
        error "${error_message}"
        exit 1
    fi
}

confirm_proceed () {
    debug "Requesting user confirmation to proceed"

    read -p "Do you wish to proceed? (yes/no) " answer
    if [[ "${answer}" != "yes" ]]; then
        debug "User elected not to proceed"
        exit 0
    fi
}

# -- Command line arguments  --------------------------------------------------

expect_argument () {
    local arg_value="${1}"
    local message="${2}"
    if [[ -z "${arg_value}" ]]; then
        error "${message}"
        usage
        exit 1
    fi
}

validate_group () {
    debug "Validating group name"

    if [[ ! -d "${working_dir}/groups/${group}" ]]; then
        error "Directory for specified group name '${group}' does not exist at path: ${bold}groups/${group}${reset}. Did you specify the correct group name?"
        exit 1
    fi
}

validate_terraform_command () {
    debug "Validating terraform command"

    disable_error_trap
    contains_element "${command}" "${supported_terraform_commands[@]}"
    exit_on_failure "${?}" "Unrecognised or unsupported Terraform command: ${bold}${command}${reset}"
    enable_error_trap
}

validate_environment_specific_code () {
  debug "Validating environment-specific infrastructure code"

  if [[ ! -d "${working_dir}/groups/${group}/profiles/${aws_profile}/${environment}" ]]; then
      error "Directory for specified environment name '${environment}' does not exist at path: ${bold}groups/${group}/profiles/${aws_profile}/${environment}${reset}. Did you specify the correct profile name?"
      exit 1
  fi
}

validate_aws_profile_config () {
    debug "Validating AWS CLI configuration profile '${aws_profile}' exists"

    disable_error_trap
    aws configure --profile ${aws_profile} list >/dev/null 2>&1
    exit_on_failure "${?}" "The AWS CLI configuration profile named '${aws_profile}' could not be found"
    enable_error_trap
}

validate_aws_profile_dir () {
  debug "Validating presence of corresponding AWS profile subdirectory"

  if [[ ! -d "${working_dir}/groups/${group}/profiles/${aws_profile}" ]]; then
      error "Directory for corresponding AWS CLI configuration profile named '${aws_profile}' not found at path: ${bold}groups/${group}/profiles/${aws_profile}"
      exit 1
  fi
}

validate_common_infra_code () {
    debug "Validating common infrastructure code"

    disable_error_trap
    environment_subdir_count=$(find groups/${group}/profiles/${aws_profile}/* -maxdepth 0 -type d | wc -l)
    enable_error_trap

    if [[ ${environment_subdir_count} -gt 0 ]]; then
        error "Refusing to continue as mode of operation is ambiguous. No environment name was specified but"
        error "environment subdirectories were detected in 'groups/${group}/profiles/${aws_profile}/'"
        error ""
        error "Did you mean to include an environment name? Use '-h|--help' for usage details; note that"
        error "group profile directories should contain either environment-specific infrastructure"
        error "configuration (with corresponding subdirectories for each named environment) or common"
        error "infrastructure code configuration, but never both"
        exit 1
    fi
}

validate_command_line_args () {
    debug "Validating command line arguments"

    expect_argument "${group}" "Required 'group' option has not been set"
    expect_argument "${command}" "Required 'command' option has not been set"
    expect_argument "${aws_profile}" "Required 'profile' option has not been set"

    validate_group
    validate_terraform_command
    validate_aws_profile_config
    validate_aws_profile_dir

    if [[ -n ${environment} ]]; then
        validate_environment_specific_code
    else
        validate_common_infra_code
    fi
}

parse_command_line_args () {

    while [[ $# -gt 0 ]]; do
        key="${1}"
        case ${key} in
            -c|--command)
                command="${2}"
                shift
                ;;
            -e|--environment)
                environment="${2}"
                shift
                ;;
            -g|--group)
                group="${2}"
                shift
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            -p|--profile)
                aws_profile="${2}"
                shift
                ;;
            -[^-]*)
                error "Unexpected option: ${1}"
                usage
                exit 1
                ;;
            --)
                debug "Found end of options delimiter '--'; will greedy match remaining command arguments"
                shift
                break
                ;;
            *)
                error "Unexpected option: ${1}"
                usage
                exit 1
                ;;
        esac
        shift
    done

    command_args="$*"

    debug "Parsed group name: '${group}'"
    debug "Parsed terraform command: '${command}'"
    debug "Parsed AWS CLI profile name: '${aws_profile}'"
    debug "Parsed terraform command arguments: '${command_args}'"

    if [[ -n ${environment} ]]; then
        debug "Parsed environment name: '${environment}'"
    fi
}

# -- Help ---------------------------------------------------------------------

usage () {
    info "Usage:"
    info "  run-terraform [OPTIONS] -- [TERRAFORM_OPTIONS]"
    info ""
    info "Options:"
    info "  -c, --command      Terraform command (supported commands: ${supported_terraform_commands[*]})"
    info "  -e, --environment  Optional enironment name; omit when applying common account-level changes"
    info "  -g, --group        Terraform source code group directory name"
    info "  -h, --help         Show this help message"
    info "  -p, --profile      The AWS Command Line Interface profile name"
    info ""
    info "Terraform options:"
    info "  Options passed to Terraform command; see 'terraform <command> --help' for valid options."
}

show_proxy_info () {
    debug "Checking for proxy environment variables"

    if [[ -n "${HTTP_PROXY:-}" ||
          -n "${HTTPS_PROXY:-}" ||
          -n "${http_proxy:-}" ||
          -n "${https_proxy:-}" ]]; then
       info "Proxy settings detected. This may affect connectivity"
   fi
}

# -- Terraform ----------------------------------------------------------------

terraform_command_accepts_vars () {
    local command="${1}"
    local commands_accepting_vars=(apply plan push refresh destroy)
    contains_element "${command}" "${commands_accepting_vars[@]}"
    return ${?}
}

configure_terraform () {
    debug "Configuring Terraform ${terraform_version}"

    region="$(aws configure get region)"
    statefile_name="${group}.tfstate"
    state_bucket="${aws_profile}.terraform-state.ch.gov.uk"

    if [[ -n ${environment} ]]; then
        workspace="${environment}"
    else
        workspace="common-${region}"
    fi

    local git_origin_url=$(git config --get remote.origin.url)
    if [[ -z ${git_origin_url} ]]; then
        error "Unable to determine 'workspace_key_prefix'; could not read URL for git remote 'origin'"
        exit 1
    fi

    workspace_key_prefix=$(basename ${git_origin_url} .git)

    export_terraform_env_var "region" "${region}"
    export_terraform_env_var "state_bucket" "${state_bucket}"
}

initialise_terraform () {
    local current_workspace=$(terraform workspace show)

    # Check if the correct workspace is already selected
    if [[ "$current_workspace" = "$workspace" ]]; then
        info "Using current workspace '${BOLD}$current_workspace${NORMAL}'"
        return 0
    fi

    # If an Incorrect workspace is selected we need to re-initialise
    info "Incorrect workspace selected '${BOLD}${current_workspace}${NORMAL}', clearing state.."
    find . -iname '.terraform*' | xargs rm -rf

    debug "Retrieving Terraform modules"
    terraform get

    debug "Initialising Terraform backend"
    terraform init \
        -backend-config="bucket=${state_bucket}" \
        -backend-config="key=${statefile_name}" \
        -backend-config="region=${region}" \
        -backend-config="workspace_key_prefix=${workspace_key_prefix}"

    # We may have pulled in a workspace after initialisation. Try selecting it...
    if terraform workspace select ${workspace} > /dev/null 2>&1; then
        info "Selected workspace '${BOLD}${workspace}${NORMAL}'"
        return 0
    fi

    # The workspace doesn't exist, try creating it...
    if terraform workspace new ${workspace}; then
        info "Created workspace '${BOLD}${workspace}${NORMAL}'"
        return 0
    else
        error "An error occurred while creating workspace '${workspace}'"
        exit 1
    fi
}

show_terraform_config () {
    info "Terraform version: ${terraform_version}"
    info "AWS CLI profile: ${bold}${aws_profile}${normal}"
    info "Region: ${bold}${region}${normal}"
    info "State bucket: ${bold}${state_bucket}${normal}"
    info "Workspace prefix: ${bold}${workspace_key_prefix}${normal}"
    info "Workspace: ${bold}${workspace}${normal}"
    info "State file: ${bold}${statefile_name}${normal}"
    info "State file path: ${bold}${state_bucket}/${workspace_key_prefix}/${workspace}/${statefile_name}${normal}"
}

# -- Entrypoint ---------------------------------------------------------------

main () {
    initialise_logging

    parse_command_line_args "${@}"
    validate_command_line_args

    export AWS_PROFILE="${aws_profile}"

    show_proxy_info

    configure_terraform
    show_terraform_config

    if [[ $- == *i* ]]; then
        confirm_proceed
    fi

    pushd "${working_dir}/groups/${group}"

    initialise_terraform

    command_string="terraform ${command}"

    if [[ -n ${command_args} ]]; then
        command_string+=" ${command_args}"
    fi

    if terraform_command_accepts_vars "${command}"; then
        command_string+=" -var-file=${working_dir}/groups/${group}/profiles/${aws_profile}"

        if [[ -n ${environment} ]]; then
            command_string+="/${environment}/vars"
        else
            command_string+="/vars"
        fi
    fi

    info "Executing command '${command_string}'"
    eval ${command_string}

    popd
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
